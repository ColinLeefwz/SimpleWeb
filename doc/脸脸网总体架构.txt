脸脸网架构文档
=============

##脸脸网总体架构

脸脸网总体上分为三大部分：

* 基于Http协议的web服务器
* 基于Xmpp协议的及时通讯服务器
* 此外再加上移动客户端。

移动客户端首先通过<http://42.121.79.210/init/init>接口获得web服务器和及时通讯服务器的ip地址。客户端随后根据返回的两个ip地址访问两个服务器集群。客户端和服务器端的接口见"**latex/接口.pdf**"文件。

服务器端之间通过标准的HTTP接口开放API。Web服务器端API包括：

* /oauth/auth?name=&pass=， 提供给Xmpp端实现用户认证。所有的用户信息都保存在Web端。
* /oauth/push_msg_info?from=&to=， 提供给push消息使用。获得from用户的姓名和to用户的push token。
* /shop/answer?sid=&uid=&msg=， 提供给商家的问答系统。用户uid发送消息msg到商家sid的现场聊天室，然后按照预先设置的规则给用户发送响应。

Xmpp端提供的API包括：

* /rest，模拟xmpp客户端发送xml消息，使用的是mod_rest模块。
* /api/room?roomid=&message=&uid=，以给定uid的身份在roomid聊天室发送消息message
* /api/block?uid=&bid=，用户uid屏蔽bid的消息
* /api/unblock?uid=&bid=，用户uid取消屏蔽用户bid
* /api/gchat?room=，获得聊天室room的消息历史
* /api/chat?uid=，获得用户uid的聊天历史
* /api/chat?uid1=&uid2=，获得用户uid1和uid2之间的聊天记录

##脸脸网Web服务器集群

脸脸网的Web服务器集群目前有两台服务器web1和web2。Web服务器集群主要包括：基于Nginx的Web接入层、基于Ror的应用层，以及基于Mongodb的数据库层。

目前redis跑在web1上,resque/resque-schedule也是。xmpp聊天机器人跑在web2上。

###Nginx

Nginx使用默认安装，启动在80端口。

 * 路径:默认路径
 * 配置文件: /etc/nginx/nginx.conf
 * 启动:sbin/nginx
 * 重启:sbin/nginx -s reload


###Redis

缓存系统采用Redis，需要2.6以上版本，因为使用了Redis Lua scripting特性。使用源代码编译安装。Redis目前只在web1服务器上启动，以后要配置为一个集群。

 this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.


 * 源代码路径:/mnt/redis-2.6.4/
 * 启动:redis-server
 
 缓存到redis中的信息：
 
1. 每个商家当天的签到数据。类型为zset，key为“ckin商家id"，值为用户id，排序值为时间。见checkin.add_to_redis方法。通过cronjob清空昨天的签到数据。
2. 每个商家累计的用户总数／女性用户总数。用户总数的key为“suac商家id”。用户总数的计算方法为：昨天累计用户总数（来自mongodb）＋今天新增用户数（来自redis实时统计）。见CheckinShopStat.rb中的相关方法。
3. Resque的异步任务。
4. 登录用户的新浪微博token。
5. Rails框架的session和cache数据。
 
 
 
###Ruby和Rails

脸脸网使用的是Ruby1.9.3和rails3.2，脸脸网使用了RVM。

 * 安装RVM: curl -L https://get.rvm.io | bash -s stable --ruby
 
项目代码位于/mnt/lianlian。

####Unicorn

Unicorn是Rails的Http服务器，启动在8081端口，作为nginx的up-stream服务器。

 * 安装：gem install unicorn
 * 配置文件: unicorn.conf.rb
 * 启动:unicorn -D -E production -c unicorn.conf.rb
 * 重启:kill -HUP \`cat log/unicorn.pid`

unicorn只适合运行短任务。所有耗时的任务，以及调用第三方API的任务，都需要异步执行。异步执行有两种办法：1、使用resque，2、考虑使用node.js。

####Resque

Resque是基于redis的ruby后台任务库。

 * 安装：gem install resque
 * 启动:INTERVAL=1 PIDFILE=./resque.pid BACKGROUND=yes QUEUE='*' rake environment resque:work

 * 停止:kill -QUIT \`cat ./resque.pid`
 
 
 后台运行的任务：
 
 * 发图时同时分享到微博
 * 拉黑用户时，通知xmpp服务器阻塞黑名单
 
 如何监控resque进程？
 
 

依赖的库：ghostscript,imagemagick，	
###God
进程监控和管理

god -c god/all.god 

###Mongodb
前面提到的几个组件都部署在连接外网的一台服务器上，ip地址192.168.1.21; 而mongodb则部署在内网的另外一台服务器上,ip地址192.168.1.22。

建立索引：rake db:mongoid:create_indexes

如何管理server端的js代码？


##Xmpp集群
Xmpp服务器采用ejabberd-2.1.11，erlang的版本是Erlang R15B01, 采用riak保存聊天记录。这几个系统全部使用源代码编译安装，可以使用“head config.log”命令查看configure时的参数。


###Erlang
源代码目录为：/mnt/otp_src_R15B01
安装: ./configure && make && sudo make install


###Ejabberd
源代码目录为：/mnt/ejabberd-2.1.11/
安装：./configure --prefix=/mnt/ejabber --enable-user=lian && make && make install
然后要将src子目录替换为git版本控制。

ejabberd安装时存在一个bug：如果指定用户，要求用户和组名字一样。在mac下创建和用户ylt一样的组并将ylt加入该组的命令如下：

	sudo dscl . create /groups/ylt gid 1000
	dscl
	> list Local/Default/Groups
	dseditgroup -o read ylt
	dseditgroup -o edit -a ylt -u ylt -t user ylt
	dscacheutil -q group

riak-erlang-client

###Riak
源代码目录：/mnt/riak/
编译：make riak
运行目录：/mnt/riak/rel/riak
查看状态：bin/riak-admin member-status

###Tsung






##系统更新
###WEB系统更新
1. 所有操作在~/lianlian目录下执行。更新前保证在服务器上测试通过：rake test
2. 如果gem file有变更，必须停止整个unicorn和resque再启动，不能简单reload。
3. 如果rake test通过，更新后却报500错误，检查unicorn的日志。
4. web app重启运行./restart.sh; 后台任务队列重启god restart resque


###XMPP系统更新
1. 所有操作在/mnt/ejabberd-2.1.11/src目录下执行。
2. 代码更新：git pull origin master && ./install.sh
3. 重启：ejabberdctl restart

